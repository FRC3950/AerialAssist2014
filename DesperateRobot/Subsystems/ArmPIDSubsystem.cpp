// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ArmPIDSubsystem.h"
#include <cmath>
#include "../Robotmap.h"
#include "../Logger.h"
#include "../Commands/MoveArm.h"
#include "../UtilFun.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"

#define ARM_UPPER_LIMIT_SWITCH_IN 1
#define ARM_LOWER_LIMIT_SWITCH_IN 1

static const double Kp = 1.0;
static const double Ki = 0.0;
static const double Kd = 1.0;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPIDSubsystem::ArmPIDSubsystem() 
	: PIDSubsystem("ArmPIDSubsystem", Kp, Ki, Kd), 
	  upperArmLimitHit(false),
	  lowerArmLimitHit(false),
	  pidEnabled(false),
	  potOrigin(0.0),
	  potOriginCheckComplete(false)
{
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ctor() called.");
	
	SetAbsoluteTolerance(0.2);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("Arm PID Subsystem", "PIDSubsystem Controller", GetPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	potentiometer1 = RobotMap::armPIDSubsystemPotentiometer1;
	armSpeedController = RobotMap::armPIDSubsystemSpeedController1;
	upperArmLimit = RobotMap::armPIDSubsystemupperArmLimit;
	lowerArmLimit = RobotMap::armPIDSubsystemlowerArmLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ctor() exiting.");
}


void ArmPIDSubsystem::SetPIDSubsystem(bool enable){

	if (enable && !pidEnabled)
	{
		Enable();
		pidEnabled = true;
	}
	
	else if (!enable && pidEnabled)
	{
		Disable();
		pidEnabled = false;
	}
}
// */


double ArmPIDSubsystem::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return potentiometer1->GetAverageVoltage();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}


void ArmPIDSubsystem::UsePIDOutput(double output) {
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	
	if (!pidEnabled)
	{
		armSpeedController->Set(0.0);
		return;
	}
	
	if ((output > 0.0) && PollUpperArmLimit())
	{
		output = 0.0;
	}
	
	else if ((output < 0.0) && PollLowerArmLimit())
	{
		output = 0.0;
	}
	
	armSpeedController->PIDWrite(output);
}

bool ArmPIDSubsystem::PollUpperArmLimit(){
#if defined(ARM_UPPER_LIMIT_SWITCH_IN)
	uint32_t switchState = upperArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm Upper Limit Switch Hit ***");
	}
	
	return limitHit;
	
#else
	return false;
#endif
}

bool ArmPIDSubsystem::PollLowerArmLimit(){
#if defined(ARM_LOWER_LIMIT_SWITCH_IN)
	uint32_t switchState = lowerArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm Lower Limit Switch Hit ***");
	}
	
	return limitHit;
#else
	return false;
#endif
}

void ArmPIDSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::InitDefaultCommand called.");
	SetDefaultCommand(new MoveArm());
	
}
static const float MAX_ANGLE = 90.0;
static const float MIN_ANGLE = 0.0;
	
float ArmPIDSubsystem::SetArmAngle(float angle, bool useErrorCorrection)
{

	static const float ERROR_CORRECTION_FACTOR = 0;
	
	if (useErrorCorrection)
	{
		angle *= ((ERROR_CORRECTION_FACTOR + 100.0) / 100.0);
	}
	
	if (angle < MIN_ANGLE)
	{
		angle = MIN_ANGLE;
	}
	else if (angle > MAX_ANGLE)
	{
		angle = MAX_ANGLE;
	}
	
	float pidInput = AngleToVoltage(angle);
	
	SetSetpoint(pidInput);
	
	return pidInput;
	
}


static const float VOLTS_PER_DEGREE_FOR_5K_POT = 0.0119; // should still be calibrated as neeeded
static const float MAX_POTENT_VOLTAGE = 1.6;

float ArmPIDSubsystem::AngleToVoltage(float angle)
{
	float complementAngle = MAX_ANGLE - angle;
	
	float result = potOrigin - (complementAngle * VOLTS_PER_DEGREE_FOR_5K_POT);
	if (result > MAX_POTENT_VOLTAGE)
	{
		result = MAX_POTENT_VOLTAGE;
	}
	
	return result;
}


float ArmPIDSubsystem::PotVoltageToAngle(float voltage)
{
	// This converts a reading of voltage off of the pot into its 
	// associated shooting arm angle.
	return ((voltage - potOrigin) / VOLTS_PER_DEGREE_FOR_5K_POT) + MAX_ANGLE;
}

static const float VOLTAGE_TOLERANCE_MIN = -0.25;
static const float VOLTAGE_TOLERANCE_MAX = 0.25;

void ArmPIDSubsystem::ManualMoveArmControl(float voltage) {
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl entered.");
	
	bool limitHit = false;
	
	if (pidEnabled)
	{
		SetPIDSubsystem(false);
	}

	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl original setting speed %f.", voltage);

	voltage = ZeroIfInRangeInclusive(voltage, VOLTAGE_TOLERANCE_MIN, VOLTAGE_TOLERANCE_MAX);
	
	if (voltage != 0)
	{
		if (voltage < 0.0)
		{
			limitHit = PollUpperArmLimit();
		}
		else if (voltage > 0.0)
		{
			limitHit = PollLowerArmLimit();
		}
		
		if (limitHit)
		{
			voltage = 0;
		}
	}

	Logger::GetInstance()->Log(Logger::kWARNING, "ArmPIDSubsystem::ManualMoverArmControl Setting voltage %f.", voltage);

	armSpeedController->Set(voltage);
}

static const double HOME_FINDING_SPEED = -1.0; //0.6;
    
void ArmPIDSubsystem::FindOriginPosition(bool forceFind) {
        
        // Check to see if the pot floor has already been
        // found.  Don't check for it again.
        if (!forceFind && potOriginCheckComplete) {
            return;
        }
        
        if (!PollUpperArmLimit()) {
            armSpeedController->Set(HOME_FINDING_SPEED);
            while (!PollUpperArmLimit()) 
            {
            }
            
            armSpeedController->Set(0.0);
        }
        
        potOrigin = ReturnPIDInput();
        //System.out.println("potOrigin = " + potOrigin);
        potOriginCheckComplete = true;
        //updateSmartDashboardPotentReading(potOrigin);
     }

    float ArmPIDSubsystem::GetPotentiometerReading() {
        double voltage = ReturnPIDInput();
        
        /*  // Enable this code for error resolution in the potentiometer
        if (voltage <= REPORT_POTENT_VOLTAGE_FLOOR) {
            ++numPotReadingsBelowFloor;
            
            if (numPotReadingsBelowFloor >= NUM_SAMPLES_BELOW_FLOOR_LIMIT) {
                //updateSmartDashboardPotentReading(voltage);
            }
        }
        else {
            if (numPotReadingsBelowFloor > 0) {
                //updateSmartDashboardPotentReading(voltage);
                numPotReadingsBelowFloor = 0;
            }
        }
        */
        return voltage;
    }



bool ArmPIDSubsystem::HasReachedTargetVoltage(float pidTargetVoltage)
{
	float actualPosition = GetPotentiometerReading();
	return fabs(actualPosition - pidTargetVoltage) <= .025;
}



