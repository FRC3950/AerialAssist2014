// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ArmPIDSubsystem.h"
#include <cmath>
#include "../Robotmap.h"
#include "../Commands/MoveArm.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"

static const double Kp = 1.0;
static const double Ki = 0.0;
static const double Kd = 1.0;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPIDSubsystem::ArmPIDSubsystem() 
	: PIDSubsystem("ArmPIDSubsystem", Kp, Ki, Kd), 
	  upperArmLimitHit(false),
	  lowerArmLimitHit(false),
	  pidEnabled(false),
	  potFloor(0.0),
	  potFloorCheckComplete(false)
{
	SetAbsoluteTolerance(0.2);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("Arm PID Subsystem", "PIDSubsystem Controller", GetPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	potentiometer1 = RobotMap::armPIDSubsystemPotentiometer1;
	armSpeedController = RobotMap::armPIDSubsystemSpeedController1;
	upperArmLimit = RobotMap::armPIDSubsystemupperArmLimit;
	lowerArmLimit = RobotMap::armPIDSubsystemlowerArmLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	
}


void ArmPIDSubsystem::SetPIDSubsystem(bool enable){

	if (enable && !pidEnabled)
	{
		Enable();
		pidEnabled = true;
	}
	
	else if (!enable && pidEnabled)
	{
		Disable();
		pidEnabled = false;
	}
}
// */


double ArmPIDSubsystem::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return potentiometer1->GetAverageVoltage();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}


void ArmPIDSubsystem::UsePIDOutput(double output) {
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	
	if (!pidEnabled)
	{
		armSpeedController->Set(0.0);
		return;
	}
	
	if ((output > 0.0) && PollUpperArmLimit())
	{
		output = 0.0;
	}
	
	else if ((output < 0.0) && PollLowerArmLimit())
	{
		output = 0.0;
	}
	
	armSpeedController->PIDWrite(output);
}

bool ArmPIDSubsystem::PollUpperArmLimit(){
	uint32_t switchState = upperArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	return (switchState != 0) ? false : true;

}

bool ArmPIDSubsystem::PollLowerArmLimit(){
	uint32_t switchState = lowerArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	return (switchState != 0) ? false : true;
}

void ArmPIDSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new MoveArm());
	
}

float ArmPIDSubsystem::SetArmAngle(float angle, bool useErrorCorrection)
{
	static const float MAX_ANGLE = 90.0;
	static const float MIN_ANGLE = 0.0;
	static const float ERROR_CORRECTION_FACTOR = 0;
	
	if (useErrorCorrection)
	{
		angle *= ((ERROR_CORRECTION_FACTOR + 100.0) / 100.0);
	}
	
	if (angle < MIN_ANGLE)
	{
		angle = MIN_ANGLE;
	}
	else if (angle > MAX_ANGLE)
	{
		angle = MAX_ANGLE;
	}
	
	float pidInput = AngleToVoltage(angle);
	
	SetSetpoint(pidInput);
	
	return pidInput;
	
}


static const float VOLTS_PER_DEGREE_FOR_5K_POT = 0.0119; // should still be calibrated as neeeded
static const float MAX_POTENT_VOLTAGE = 1.6;

float ArmPIDSubsystem::AngleToVoltage(float angle)
{
	float result = angle * VOLTS_PER_DEGREE_FOR_5K_POT + potFloor;
	if (result > MAX_POTENT_VOLTAGE)
	{
		result = MAX_POTENT_VOLTAGE;
	}
	return result;
}


float ArmPIDSubsystem::VoltageToAngle(float voltage)
{
	return (voltage - potFloor) / VOLTS_PER_DEGREE_FOR_5K_POT;
}



void ArmPIDSubsystem::ManualMoveArmControl(float y){
	bool limitHit = false;
	
	if (pidEnabled)
	{
		SetPIDSubsystem(false);
	}
	
	if (y < 0.0)
	{
		limitHit = PollLowerArmLimit();
	}
	else if (y > 0.0)
	{
		limitHit = PollUpperArmLimit();
	}
	
	if (limitHit)
	{
		y = 0;
	}
	
	
	armSpeedController->Set(y);
}

static const double HOME_FINDING_SPEED = 1.0; //0.6;
    
void ArmPIDSubsystem::findHomePosition(bool forceFind) {
        
        // Check to see if the pot floor has already been
        // found.  Don't check for it again.
        if (!forceFind && potFloorCheckComplete) {
            return;
        }
        
        if (!PollLowerArmLimit()) {
            armSpeedController->Set(HOME_FINDING_SPEED);
            while (!PollLowerArmLimit()) {
//                System.out.println("Moving the shooter down.");
            }
            
            armSpeedController->Set(0.0);
        }
        
        potFloor = ReturnPIDInput();
        //System.out.println("potFloor = " + potFloor);
        potFloorCheckComplete = true;
        //updateSmartDashboardPotentReading(potFloor);
     }



    float ArmPIDSubsystem::GetPotentiometerReading() {
        double voltage = ReturnPIDInput();
        
        /*  // Enable this code for error resolution in the potentiometer
        if (voltage <= REPORT_POTENT_VOLTAGE_FLOOR) {
            ++numPotReadingsBelowFloor;
            
            if (numPotReadingsBelowFloor >= NUM_SAMPLES_BELOW_FLOOR_LIMIT) {
                //updateSmartDashboardPotentReading(voltage);
            }
        }
        else {
            if (numPotReadingsBelowFloor > 0) {
                //updateSmartDashboardPotentReading(voltage);
                numPotReadingsBelowFloor = 0;
            }
        }
        */
        return voltage;
    }



bool ArmPIDSubsystem::HasReachedTargetVoltage(float pidTargetVoltage)
{
	float actualPosition = GetPotentiometerReading();
	return fabs(actualPosition - pidTargetVoltage) <= .025;
}



