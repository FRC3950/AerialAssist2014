// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveSubsystem.h"
#include "../Robotmap.h"
#include "../Commands/DriveCommand.h"
DriveSubsystem::DriveSubsystem() : Subsystem("DriveSubsystem") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	speedController1 = RobotMap::driveSubsystemSpeedController1;
	speedController2 = RobotMap::driveSubsystemSpeedController2;
	speedController3 = RobotMap::driveSubsystemSpeedController3;
	speedController4 = RobotMap::driveSubsystemSpeedController4;
	robotDriveMecanum = RobotMap::driveSubsystemRobotDriveMecanum;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}
    
void DriveSubsystem::InitDefaultCommand() {
	printf("DriveSubsystem::InitiDefaultCommand -> Called.\n");
	
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.


const float DriveToleranceX = 0.1;
const float DriveToleranceY = 0.1;

void DriveSubsystem::MecanumDrive(float x, float y, float twist) { 
	//printf ("DriveSubsystem::MecanumDrive -> Entered.\n");

	// This is shorthand for assignment based on an if statement.
	// It says that if (y > DriveTolerance) 
	// then use the current value of y.
	// otherwise use 0.0
	// Do the same for x as well.
	
	y = (y > DriveToleranceY) ? y : 0.0;
	x = (x > DriveToleranceX) ? x : 0.0;

	printf("x = %f, y = %f, twist = %f\n", x, y, twist);
	
	robotDriveMecanum->MecanumDrive_Cartesian(x, y, twist);
	
	// this causes 'drive' to be a cartesian mecanum drive
	// retreives X Y and Rotation of m_blueStick to determine the drive
	// fourth option yet to be added is the gyro.
}

void DriveSubsystem::TankDrive(float left, float right)
{
	printf("DriveSubSystem::TankDrive->left = %f, right = %f\n", left, right);
	robotDriveMecanum->TankDrive(left, right);
}
