// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ArmPIDSubsystem.h"
#include <cmath>
#include "../Robotmap.h"
#include "../Logger.h"
#include "../Commands/MoveArm.h"
#include "../UtilFun.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"

#define ARM_UPPER_LIMIT_SWITCH_IN 1
#define ARM_LOWER_LIMIT_SWITCH_IN 1
#define POLL_THE_POT 1

static const double Kp = 1.0;
static const double Ki = 0.0;
static const double Kd = 1.0;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPIDSubsystem::ArmPIDSubsystem() 
	: PIDSubsystem("ArmPIDSubsystem", Kp, Ki, Kd), 
	  upperArmLimitHit(false),
	  lowerArmLimitHit(false),
	  pidEnabled(false),
	  potOrigin(0.0),
	  potOriginCheckComplete(false)
{
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ctor() called.");
	
	SetAbsoluteTolerance(0.2);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("Arm PID Subsystem", "PIDSubsystem Controller", GetPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	potentiometer1 = RobotMap::armPIDSubsystemPotentiometer1;
	armSpeedController = RobotMap::armPIDSubsystemSpeedController1;
	upperArmLimit = RobotMap::armPIDSubsystemupperArmLimit;
	lowerArmLimit = RobotMap::armPIDSubsystemlowerArmLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ctor() exiting.");
}


void ArmPIDSubsystem::SetPIDSubsystem(bool enable){

	if (enable && !pidEnabled)
	{
		Enable();
		pidEnabled = true;
	}
	
	else if (!enable && pidEnabled)
	{
		Disable();
		pidEnabled = false;
	}
}
// */


double ArmPIDSubsystem::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return potentiometer1->GetAverageVoltage();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}


void ArmPIDSubsystem::UsePIDOutput(double output) {
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	
	if (!pidEnabled)
	{
		armSpeedController->Set(0.0);
		return;
	}
	
	if ((output < 0.0) && PollUpperArmLimit())
	{
		output = 0.0;
	}
	
	else if ((output > 0.0) && PollLowerArmLimit())
	{
		output = 0.0;
	}
	
	armSpeedController->PIDWrite(output);
}

bool ArmPIDSubsystem::PollUpperArmLimit(){
#if defined(ARM_UPPER_LIMIT_SWITCH_IN)
	uint32_t switchState = upperArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm Upper Limit Switch Hit ***");
	}
	
	return limitHit;
	
#else
	return false;
#endif
}

bool ArmPIDSubsystem::PollLowerArmLimit(){
#if defined(ARM_LOWER_LIMIT_SWITCH_IN)
	uint32_t switchState = lowerArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm Lower Limit Switch Hit ***");
	}
	
	return limitHit;
#else
	return false;
#endif
}

void ArmPIDSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::InitDefaultCommand called.");
	SetDefaultCommand(new MoveArm());
	
}

float ArmPIDSubsystem::GetArmAngle()
{
	float currVoltage = GetPotentiometerReading();
	
	return this->PotVoltageToAngle(currVoltage);
}

float ArmPIDSubsystem::SetRelativePIDTarget(float target)
{

	if (!pidEnabled)
	{
		SetPIDSubsystem(true);
	}
	
	float pidInput = target + potOrigin;
	
	SetSetpoint(pidInput);
	
	return pidInput;
}

static const float MAX_ANGLE = 90.0;
static const float MIN_ANGLE = 0.0;
	
float ArmPIDSubsystem::SetArmAngle(float angle, bool useErrorCorrection)
{

	static const float ERROR_CORRECTION_FACTOR = 0;
	
	if (useErrorCorrection)
	{
		angle *= ((ERROR_CORRECTION_FACTOR + 100.0) / 100.0);
	}
	
	if (angle < MIN_ANGLE)
	{
		angle = MIN_ANGLE;
	}
	else if (angle > MAX_ANGLE)
	{
		angle = MAX_ANGLE;
	}
	
	float pidInput = AngleToVoltage(angle);

	if (!pidEnabled)
	{
		SetPIDSubsystem(true);
	}
	
	SetSetpoint(pidInput);
	
	return pidInput;
	
}


static const float VOLTS_PER_DEGREE_FOR_5K_POT = 0.0156; // should still be calibrated as neeeded
static const float MAX_POTENT_VOLTAGE = 2.6217;			 // When at 0 degrees		
static const float MIN_POTENT_VOLTAGE = 1.2206;			 // When at 90 degrees

float ArmPIDSubsystem::AngleToVoltage(float angle)
{
	float complementAngle = MAX_ANGLE - angle;
	
//	float result = potOrigin - (complementAngle * VOLTS_PER_DEGREE_FOR_5K_POT);
	float result = potOrigin + (complementAngle * VOLTS_PER_DEGREE_FOR_5K_POT);
	if (result > MAX_POTENT_VOLTAGE)
	{
		result = MAX_POTENT_VOLTAGE;
	}

	
	return result;
}


float ArmPIDSubsystem::PotVoltageToAngle(float voltage)
{
	// This converts a reading of voltage off of the pot into its 
	// associated shooting arm angle.
	// return ((voltage - potOrigin) / VOLTS_PER_DEGREE_FOR_5K_POT) + MAX_ANGLE;
	//return ((voltage + potOrigin) / VOLTS_PER_DEGREE_FOR_5K_POT) + MAX_ANGLE;
	float complementAngle = (voltage - potOrigin) / VOLTS_PER_DEGREE_FOR_5K_POT;
	return MAX_ANGLE - complementAngle;
}

static const float VOLTAGE_TOLERANCE_MIN = -0.25;
static const float VOLTAGE_TOLERANCE_MAX = 0.25;
static const float VOLTAGE_SCALE_FACTOR = .65;

void ArmPIDSubsystem::ManualMoveArmControl(float voltage) {
	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl entered.");
	
	bool limitHit = false;
	
	if (pidEnabled)
	{
		SetPIDSubsystem(false);
	}

	Logger::GetInstance()->Log(Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl original setting speed %f.", voltage);
	voltage *= VOLTAGE_SCALE_FACTOR;
	voltage = ZeroIfInRangeInclusive(voltage, VOLTAGE_TOLERANCE_MIN, VOLTAGE_TOLERANCE_MAX);
	
	if (voltage != 0)
	{
		if (voltage < 0.0)
		{
			limitHit = PollUpperArmLimit();
		}
		else if (voltage > 0.0)
		{
			limitHit = PollLowerArmLimit();
		}
		
		if (limitHit)
		{
			voltage = 0;
		}
	}

	if (Logger::GetInstance()->IsLogging(Logger::kWARNING))
	{
		 if ((voltage != 0.0) || ((voltage == 0.0) && (armSpeedController->Get() != 0.0)))
		 {
			 Logger::GetInstance()->Log(Logger::kWARNING, "ArmPIDSubsystem::ManualMoverArmControl Setting voltage %f.", voltage);
		 }
	}
	
#if defined(POLL_THE_POT)
	double potVoltage = GetPotentiometerReading();
	Logger::GetInstance()->Log(Logger::kINFO, "*** Arm POT value = %g ***", potVoltage);
	SmartDashboard::PutNumber("Arm Pot", potVoltage);

#endif
	armSpeedController->Set(voltage);
}

static const double POT_ORIGIN_FINDING_SPEED = -0.6; //0.6;
static const double POT_ORIGIN_READ_DELAY_IN_SECS = 0.5;
void ArmPIDSubsystem::FindOriginPosition(bool forceFind) {
        
	// Check to see if the pot floor has already been
	// found.  Don't check for it again.
	if (!forceFind && potOriginCheckComplete) 
	{
		Logger::GetInstance()->Log(Logger::kWARNING, "*** Finding Arm POT Origin - Already found. Ignoring. ***");
		
		return;
	}
	
	SetPIDSubsystem(false);
	
	Logger::GetInstance()->Log(Logger::kWARNING, "*** Finding Arm POT Origin ***");
	int count = 0;
	
	if (!PollUpperArmLimit()) {
		armSpeedController->Set(POT_ORIGIN_FINDING_SPEED);
		while (!PollUpperArmLimit()) 
		{
			if ((++count % 4) == 0) {
				Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm POT value = %f ***", potentiometer1->GetVoltage());
			}
		}
		
		armSpeedController->Set(0.0);
		
		// Delay reading the pot voltage to give things a chance to stabilize.
		Wait(POT_ORIGIN_READ_DELAY_IN_SECS);
	}
	
	potOrigin = (float)potentiometer1->GetVoltage();
	Logger::GetInstance()->Log(Logger::kWARNING, "*** Arm POT Origin set to %f ***", potOrigin);
	potOriginCheckComplete = true;
	SmartDashboard::PutNumber("Pot Origin", potOrigin);
 }

float ArmPIDSubsystem::GetPotentiometerReading() {
	double voltage = (float)potentiometer1->GetVoltage();
	
	/*  // Enable this code for error resolution in the potentiometer
	if (voltage <= REPORT_POTENT_VOLTAGE_FLOOR) {
		++numPotReadingsBelowFloor;
		
		if (numPotReadingsBelowFloor >= NUM_SAMPLES_BELOW_FLOOR_LIMIT) {
			//updateSmartDashboardPotentReading(voltage);
		}
	}
	else {
		if (numPotReadingsBelowFloor > 0) {
			//updateSmartDashboardPotentReading(voltage);
			numPotReadingsBelowFloor = 0;
		}
	}
	*/
	return voltage;
}


static const float PID_TARGET_EPSILON = 0.01;
bool ArmPIDSubsystem::HasReachedTargetVoltage(float pidTargetVoltage)
{
	float actualPosition = GetPotentiometerReading();
	return fabs(actualPosition - pidTargetVoltage) <= PID_TARGET_EPSILON;
}



