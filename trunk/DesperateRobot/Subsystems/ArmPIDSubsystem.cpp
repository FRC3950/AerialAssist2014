// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ArmPIDSubsystem.h"
#include <cmath>
#include "../Robotmap.h"
#include "../Logger.h"
#include "../LoggingComponentDefs.h"
#include "../SmartDashboardFields.h"
#include "../UtilFun.h"
#include "../Commands/MoveArm.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"

#define ARM_UPPER_LIMIT_SWITCH_IN 1
#define ARM_LOWER_LIMIT_SWITCH_IN 1
#define POLL_THE_POT 1

static const double Kp = 1.0;
static const double Ki = 0.0;
static const double Kd = 1.0;

static const float PotOriginDefault = 1.215;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPIDSubsystem::ArmPIDSubsystem() 
	: PIDSubsystem("ArmPIDSubsystem", Kp, Ki, Kd), 
	  upperArmLimitHit(false),
	  lowerArmLimitHit(false),
	  pidEnabled(false),
	  potOrigin(PotOriginDefault),
	  potOriginCheckComplete(false)
{
	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "ArmPIDSubsystem::ctor() called.");
	
	SetAbsoluteTolerance(0.2);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("Arm PID Subsystem", "PIDSubsystem Controller", GetPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	potentiometer1 = RobotMap::armPIDSubsystemPotentiometer1;
	armSpeedController = RobotMap::armPIDSubsystemSpeedController1;
	upperArmLimit = RobotMap::armPIDSubsystemupperArmLimit;
	lowerArmLimit = RobotMap::armPIDSubsystemlowerArmLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "ArmPIDSubsystem::ctor() exiting.");
	SmartDashboard::PutBoolean(ReadyToFireField, false);
}

void ArmPIDSubsystem::SetPIDSubsystem(bool enable){

	if (enable && !pidEnabled)
	{
		Enable();
		pidEnabled = true;
	}
	
	else if (!enable && pidEnabled)
	{
		Disable();
		pidEnabled = false;
	}
}
// */


double ArmPIDSubsystem::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return potentiometer1->GetAverageVoltage();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}


void ArmPIDSubsystem::UsePIDOutput(double output) {
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	
	if (!pidEnabled)
	{
		armSpeedController->Set(0.0);
		return;
	}
	
	if ((output < 0.0) && PollUpperArmLimit())
	{
		output = 0.0;
	}
	
	else if ((output > 0.0) && PollLowerArmLimit())
	{
		output = 0.0;
	}
	
	armSpeedController->PIDWrite(output);
}

bool ArmPIDSubsystem::PollUpperArmLimit(){
#if defined(ARM_UPPER_LIMIT_SWITCH_IN)
	uint32_t switchState = upperArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Arm Upper Limit Switch Hit ***");
	}
	
	return limitHit;
	
#else
	return false;
#endif
}

bool ArmPIDSubsystem::PollLowerArmLimit(){
#if defined(ARM_LOWER_LIMIT_SWITCH_IN)
	uint32_t switchState = lowerArmLimit->Get();
	// This assumes the limit switch is normally closed
	// and reading non-zero
	// When it reads zero, the switch is open, inidicating the limit was hit.
	bool limitHit = (switchState == 0) ? false : true;
	
	if (limitHit)
	{
		Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Arm Lower Limit Switch Hit ***");
	}
	
	return limitHit;
#else
	return false;
#endif
}

void ArmPIDSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "ArmPIDSubsystem::InitDefaultCommand called.");
	SetDefaultCommand(new MoveArm());
	
}

float ArmPIDSubsystem::SetAbsolutePIDTarget(float target)
{

	if (!pidEnabled)
	{
		SetPIDSubsystem(true);
	}
	
	SetSetpoint(target);
	
	return target;
}

float ArmPIDSubsystem::SetRelativePIDTarget(float target)
{

	if (!pidEnabled)
	{
		SetPIDSubsystem(true);
	}
	
	float pidInput = target + potOrigin;
	
	SetSetpoint(pidInput);
	
	return pidInput;
}

static const float VOLTAGE_TOLERANCE_MIN = -0.25;
static const float VOLTAGE_TOLERANCE_MAX = 0.25;
static const float VOLTAGE_SCALE_FACTOR = .65;

void ArmPIDSubsystem::ManualMoveArmControl(float voltage) {
//	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl entered.");
	
	bool limitHit = false;
	
	if (pidEnabled)
	{
		SetPIDSubsystem(false);
	}

//	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "ArmPIDSubsystem::ManualMoverArmControl original setting speed %f.", voltage);
	voltage *= VOLTAGE_SCALE_FACTOR;
	voltage = ZeroIfInRangeInclusive(voltage, VOLTAGE_TOLERANCE_MIN, VOLTAGE_TOLERANCE_MAX);
	
	if (voltage != 0)
	{
		if (voltage < 0.0)
		{
			limitHit = PollUpperArmLimit();
		}
		else if (voltage > 0.0)
		{
			limitHit = PollLowerArmLimit();
		}
		
		if (limitHit)
		{
			voltage = 0;
		}
	}

	if (Logger::GetInstance()->IsLogging(ArmPIDSubsystemLogId, Logger::kWARNING))
	{
		 if ((voltage != 0.0) || ((voltage == 0.0) && (armSpeedController->Get() != 0.0)))
		 {
//			 Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "ArmPIDSubsystem::ManualMoverArmControl Setting voltage %f.", voltage);
		 }
	}
	
#if defined(POLL_THE_POT)
	static int counter = 0;
	
	if ((++counter % 50) == 0)
	{
		counter = 0;
		double potVoltage = GetPotentiometerReading();
	//	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kINFO, "*** Arm POT value = %g ***", potVoltage);
		SmartDashboard::PutNumber("Arm Pot", potVoltage);
	}
#endif
	armSpeedController->Set(voltage);
}

static const double POT_ORIGIN_FINDING_SPEED = -0.6; //0.6;
static const double POT_ORIGIN_READ_DELAY_IN_SECS = 0.5;
void ArmPIDSubsystem::FindOriginPosition(bool forceFind) {
        
	// Check to see if the pot floor has already been
	// found.  Don't check for it again.
	if (!forceFind && potOriginCheckComplete) 
	{
		Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Finding Arm POT Origin - Already found. Ignoring. ***");
		
		return;
	}
	
	SetPIDSubsystem(false);
	
	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Finding Arm POT Origin ***");
	int count = 0;
	
	if (!PollUpperArmLimit()) {
		armSpeedController->Set(POT_ORIGIN_FINDING_SPEED);
		while (!PollUpperArmLimit()) 
		{
			if ((++count % 4) == 0) {
				Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Arm POT value = %f ***", potentiometer1->GetVoltage());
			}
		}
		
		armSpeedController->Set(0.0);
		
		// Delay reading the pot voltage to give things a chance to stabilize.
		Wait(POT_ORIGIN_READ_DELAY_IN_SECS);
	}
	
	potOrigin = (float)potentiometer1->GetVoltage();
	Logger::GetInstance()->Log(ArmPIDSubsystemLogId, Logger::kWARNING, "*** Arm POT Origin set to %f ***", potOrigin);
	potOriginCheckComplete = true;
	SmartDashboard::PutNumber("Pot Origin", potOrigin);
 }

float ArmPIDSubsystem::GetPotentiometerReading() {
	double voltage = (float)potentiometer1->GetVoltage();
	
	/*  // Enable this code for error resolution in the potentiometer
	if (voltage <= REPORT_POTENT_VOLTAGE_FLOOR) {
		++numPotReadingsBelowFloor;
		
		if (numPotReadingsBelowFloor >= NUM_SAMPLES_BELOW_FLOOR_LIMIT) {
			//updateSmartDashboardPotentReading(voltage);
		}
	}
	else {
		if (numPotReadingsBelowFloor > 0) {
			//updateSmartDashboardPotentReading(voltage);
			numPotReadingsBelowFloor = 0;
		}
	}
	*/
	return voltage;
}

void ArmPIDSubsystem::SetReadyToFireField(bool setting)
{
	SmartDashboard::PutBoolean(ReadyToFireField, setting);
}

void ArmPIDSubsystem::UpdateReadyToFireField(float targetVoltage)
{
	UpdateReadyToFireField(targetVoltage, GetPotentiometerReading());
}

static float const SHOOTING_ANGLE_UPPER_EPSILON = 0.00;
static float const SHOOTING_ANGLE_LOWER_EPSILON = 0.02;

void ArmPIDSubsystem::UpdateReadyToFireField(float targetVoltage, float currVoltage)
{
	static int counter = 0;
	
	if ((++counter % 50) != 0)
	{
		return;
	}
	
	counter = 0;
	bool readyToFire = InRangeInclusive(currVoltage,
			                            targetVoltage - SHOOTING_ANGLE_LOWER_EPSILON,
			                            targetVoltage + SHOOTING_ANGLE_UPPER_EPSILON);

	SmartDashboard::PutBoolean(ReadyToFireField, readyToFire);
}

bool ArmPIDSubsystem::UpdateReadyToFireField(float targetVoltage, 
		                                     float currVoltage,
		                                     float lowerEpsilon,
		                                     float upperEpsilon)
{
	static int counter = 0;
	
	
	bool readyToFire = InRangeInclusive(currVoltage,
			                            targetVoltage - lowerEpsilon,
			                            targetVoltage + upperEpsilon);

	if ((++counter % 50) == 0)
	{
		counter = 0;
		SmartDashboard::PutBoolean(ReadyToFireField, readyToFire);
	}
	
	return readyToFire;
}

static const float PID_TARGET_EPSILON = 0.01;
bool ArmPIDSubsystem::HasReachedTargetVoltage(float pidTargetVoltage)
{
	float actualPosition = GetPotentiometerReading();
	return fabs(actualPosition - pidTargetVoltage) <= PID_TARGET_EPSILON;
}



